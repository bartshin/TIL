#### custom element
- VisualElement를 base로 하는 class를 만들고 instance를 root에 추가해주면 사용할 수 있다   
- uss로 원하는 대로 커스텀 할 수 있는 장점이 있지만 Update등의 event function을 사용하기 어려운 단점이 있다   
- joystick 예제    
  VisualElement class 코드   
```C#
public class Joystick : VisualElement {
  public Vector2 Input => this.normalizedInput;
  const float HandleRadius = 70f;
  const float ResetDelay = 0.3f;
  float handleRadius;
  float resetDelay;
  float maxDist => this.handleRadius * 0.5f;
  Vector2 normalizedInput;
  Button handle;
  bool isHandlePressed;
  Vector2 pressedPosition;
  Vector2 handleOffset;

  public Joystick(float radius = Joystick.HandleRadius, float resetDelay = Joystick.ResetDelay) { 
    this.handleRadius = radius;
    this.resetDelay = resetDelay;
    this.normalizedInput = new();
    this.pressedPosition = new();
    this.handleOffset = new();
    this.CreateUI();
  }

  public IEnumerator<Action> CreateResetHandleRoutine(Action onEnded) {
    while (this.handleOffset.magnitude > 0.01f) {
      this.handleOffset = Vector2.Lerp(
          this.handleOffset,
          Vector2.zero,
          10.0f * Time.deltaTime
          );
      this.MoveHandle();
      yield return (null);
    }
    onEnded.Invoke();
  }

  void CreateUI() {
    this.AddToClassList("joystickContainer");
    this.handle = new Button(); 
    this.handle.AddToClassList("joystickHandle");
    this.handle.style.width = this.handleRadius * 2;
    this.handle.style.height = this.handleRadius * 2;
    this.handle.RegisterCallback<PointerDownEvent>(
        this.OnHandlePress, TrickleDown.TrickleDown);
    this.handle.RegisterCallback<PointerUpEvent>(
        this.OnHandleRelease);
    this.handle.RegisterCallback<PointerMoveEvent>(
      evt => { 
        if(this.isHandlePressed)
          this.OnHandleMove(evt);
      }); 
    this.Add(this.handle);
  }

  void OnHandlePress(PointerDownEvent evt) {
    this.ClearResetHandle();
    this.isHandlePressed = true;
    this.AddToClassList("joystickContainer-active");
    this.handle.AddToClassList("joystickHandle-active");
    this.pressedPosition.x = evt.position.x;
    this.pressedPosition.y = evt.position.y;
  }

  void OnHandleRelease(PointerUpEvent evt) {
    this.isHandlePressed = false;
    this.RemoveFromClassList("joystickContainer-active");
    this.handle.RemoveFromClassList("joystickHandle-active");
    this.normalizedInput = Vector2.zero;
    this.handle.style.transitionProperty = new List<StylePropertyName> { "translate" };
    this.handle.style.transitionDuration = new List<TimeValue>{ this.resetDelay };
    this.handleOffset = Vector2.zero;
    this.MoveHandle();
  }

  void ClearResetHandle() {
    this.handle.style.transitionDuration = null;
    this.handle.style.transitionProperty = null;
    this.handleOffset = Vector2.zero;
  }

  void OnHandleMove(PointerMoveEvent evt) {
    this.handleOffset.x = Math.Clamp(evt.position.x - this.pressedPosition.x, - this.maxDist, this.maxDist);
    this.handleOffset.y = Math.Clamp(evt.position.y - this.pressedPosition.y, - this.maxDist, this.maxDist);
    this.MoveHandle();
    this.normalizedInput = new Vector2(this.handleOffset.x / this.maxDist, - this.handleOffset.y / this.maxDist).normalized;
  }

  void MoveHandle() {
    this.handle.style.translate = new StyleTranslate(
        new Translate(this.handleOffset.x, this.handleOffset.y)
        );
  } 
}
```
	uss 코드   
```css
.joystickContainer {
  position: absolute;
  left: 5%;
  bottom: 5%;
  width: 200px;
  min-width: 200px;
  height: 200px;
  min-height: 200px;
  border-radius: 50%;
  border-width: 4px;
  border-color: rgba(120, 120, 120, 0.4);
  background-color: rgba(120, 120, 120, 0.2);
  justify-content: center;
  align-items: center;
  margin: 0;
  padding: 0;
  scale: 1.0;
}

.joystickContainer:hover {
  scale: 1.1;
}

.joystickContainer-active {
  scale: 1.1;
  border-color: white !important;
}

.joystickHandle {
  border-radius: 50%;
  border-width: 0;
  background-color: rgba(3, 167, 145, 0.5);
}

.joystickHandle-active {
  background-color: rgba(129, 231, 175, 1.0) !important;
}
```
#### button   
- [CallbackEventHandler.RegisterCallback\<ClickEvent>](https://docs.unity3d.com/6000.0/Documentation/ScriptReference/UIElements.CallbackEventHandler.RegisterCallback.html)를 사용해서 button click을 사용할 수 있다   
- RegisterCallback\<PointerDown>을 사용하려면 [UIElements.TrickleDown.TrickleDown](https://docs.unity3d.com/6000.0/Documentation/ScriptReference/UIElements.TrickleDown.html)을 두번째 argument로 전달해야 동작한다   
- TricleDown을 사용하면 기본값으로 설정된 BubbleUp phase가 아니라 TrickleDown phase에 callback이 실행된다   