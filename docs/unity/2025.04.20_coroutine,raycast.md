## coroutine
- coroutine은 thread가 아니기 때문에 main thread에서 실행되고 CPU의 실행 시간을 줄여주지 않는다   
- main thread에서 async function을 긴 시간에 걸쳐 실행하거나 여러 frame에 걸쳐 나누어 실행할 수 있다   
- MonoBehaviour의 SetActive(false)를 실행하여 coroutine을 중지할 수 있다 (enabled를 false로 바꾸는 것은 중지시키지 않는다)   
- coroutine은 첫 yield return 이후부터는 coroutine을 관리하는 class와 함께DelayedCallManager에서 실행된다   
- coroutine을 관리하는 class에 필요한 메모리와 coroutine function 내부의 local variable들을 heap으로 복사하기 위한 메모리 overhead가 발생한다   
#### Unity null   
- 다음과 같이  정상적으로 접근할 수 있는 c# object라도 unity에서는 null으로 판정될 수 있다 (custom operator \== override)   
  1. 에디터에서 디버깅에 사용할 목적으로 unity가 생성한 object에 접근하려고 한 경우   
  2. C#의 G.C가 아직 처리하지 않았지만 해당 object에 대한 Unity engine의 C++ 코드의 object가 삭제된 경우 (사용할 수 없는 상태)   
- UnityEngine.Object는 obj \== null 과 obj is null의 결과가 다르기 때문에 동일하게 사용할 수 없고 ?.method() 도 동일하게 사용할 수 없다   

#### Script class init
[RuntimeInitializeOnLoadMethodAttribute](https://docs.unity3d.com/6000.0/Documentation/ScriptReference/RuntimeInitializeOnLoadMethodAttribute.html)를 활용하기     

> **읽어 볼 내용**
-  [UnityEngine.Object](https://docs.unity3d.com/6000.0/Documentation/Manual/class-Object.html)   
- [C# Job System](https://docs.unity3d.com/2022.3/Documentation/Manual/JobSystem.html)  